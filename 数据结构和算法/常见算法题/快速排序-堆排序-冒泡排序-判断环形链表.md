### 冒泡排序

+ 每次冒泡比较相邻元素，一次大循环会将最大元素移动到队尾

~~~js
// 未优化冒泡
const bubbleSort = (arr) => {
    const len = arr.length;
    if (len < 2) return arr;
    // 外层循环控制比较轮次，n个数，比较n-1次
    for (let i = 0; i < len-1; i++) {
        // 内存循环，两两比较交换
        for (let j = 0; j < len-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
            }
        }
    }
}
~~~

~~~js
// 优化冒泡排序
// 当前一次外层for循环，没有数据发生变化时，说明已经有序
const bubbleSort2 = (arr) => {
    const len = arr.length;
    if (len < 2) return arr;
    fpr (let i = 0; i < len-1; i++) {
        let hasChange = false;
        for (let j = 0; j < len-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
                hasChange = true;
            }
        }
        if (!hasChange) break;
    }
}
~~~

原地排序，稳定排序，时间复杂度O(n^2)

### 快速排序

~~~js
// 每次执行都会用到两个数组空间
const quickSort1 = arr => {
    if (arr.length < 2) {
        return arr;
    } else {
        const pivot = arr[0];
        const left = [], middle = [], right = [];
        arr.forEach(cur => {
            if (cur == pivot) middle.push(cur);
            else if (cur > pivot) right.push(cur)
            else left.push(cur)
        })
        return quickSort1(left).concat(middle, quickSort1(right));
    }
}
~~~



### 堆排序

~~~js

~~~

