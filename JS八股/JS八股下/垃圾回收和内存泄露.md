# 垃圾回收和内存泄露

## 1 浏览器的垃圾回收机制

### 1.1 垃圾回收概念

**垃圾回收（Garbage Collection）：**JS执行代码时，需要内存空间来存储变量和值。当变量不再参与运行时，需要系统收回被占用的内存空间。

**回收机制：**

+ JS具有自动垃圾回收机制，会定期找到那些不再使用的变量，释放掉其占用的内存
+ JS中变量分为：局部变量和全局变量。全局变量的声明周期持续到页面卸载；局部变量声明在函数中，生命周期从函数执行开始到函数执行结束，在这个过程中，局部变量会在堆或栈中存储他们的值，当函数执行完后，占用的空间被释放
+ 不过，当局部变量被外部函数使用时，一种情况就是闭包，在函数执行完毕后，函数外部的变量依然指向函数内部的局部变量，局部变量仍然在被使用，所以不会回收。

### 1.2 垃圾回收方式

**（1）标记清除**（使用频率多）

变量进入环境，标记为`“进入环境”`，被标记为“进入环境”的变量不能被回收。当变量离开环境，被标记`“离开环境”`，会被内存释放。

引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 `根` 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 `全局Window对象`、`文档DOM树` 等

整个标记清除具体过程：

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

**优点：**实现简单

**缺点：**清除内存后，剩余内存对象的位置不变，会产生`内存碎片`

假设我们新建对象分配内存时需要大小为 `size`，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 `size` 的块才能为其分配（如下图）

![image-20220910002617227](C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20220910002617227.png)

而==标记整理（Mark-Compact）算法==就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）**向内存的一端移动**，最后清理掉边界的内存（如下图）

![image-20220910004918235](C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20220910004918235.png)

**（2）引用计数法**（使用频率少）

引用计数就是**跟踪记录每个值被引用的次数**。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个**引用次数变为0时，说明这个变量已经没有价值**，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。

~~~js
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
~~~

如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 `test` 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放。

**优点：**

+ 更**清晰**，当引用计数值为0，也就是在变成垃圾的那一刻就会被回收

+ **标记清除算法**需要**每隔一段时间**进行一次，那在应用程序（JS脚本）运行过程中线程就必须要**暂停**去执行一段时间的 `GC`，另外，标记清除算法需要**遍历**堆里的活动以及非活动对象来清除，而**引用计数**则只需要在**引用时计数**就可以了

**缺点：**

需要一个**计数器**，而此计数器需要占很大的位置，因为我们也**不知道被引用数量的上限**



**（3）V8引擎对GC的优化**

V8 的垃圾回收策略主要基于**分代式垃圾回收机制**，V8 中将堆内存分为**新生代**和**老生代**两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）

![image-20220910004109802](C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20220910004109802.png)

**新生代垃圾回收**

新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法`

`Cheney算法` 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为 `空闲区`，如下图所示

![image-20220910004325400](C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20220910004325400.png)

新加入的对象都会存放到使用区，当**使用区快被写满时，就需要执行一次垃圾清理操作**

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，**标记完成之后将使用区的活动对象复制进空闲区并进行排序**，随后进入垃圾清理阶段，即**将非活动对象占用的空间清理掉**。最后进行角色互换，把**原来的使用区变成空闲区，把原来的空闲区变成使用区**

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

**老生代垃圾回收**

老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，**所以老生代垃圾回收器采用标记整理算法**

### 1.3 减少垃圾回收

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

+ **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。

+ **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。

+ **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面

==哪种情况会导致内存泄露？==

1. **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

2. **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

3. **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。

4. **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。