## HTTP常见面试题

### HTTP基本概念

#### HTTP是什么

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

> 那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议 ，这种说法正确吗？

这种说法是**不正确**的。因为也可以是「服务器< -- >服务器」，所以采用**两点之间**的描述会更准确。

#### HTTP常见状态码

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221020160851997.png" alt="image-20221020160851997" style="zoom:33%;" />

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。



`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」200 OK表示客户端发来的请求被服务器端正常处理了。

- 「**204 No Content**」该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

  

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
  - **使用场景：**
    - 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
    - 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

- 「**302 Found**」表示**临时重定向**，该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
  - 使用场景：
    - 当我们在做活动时，登录到首页自动重定向，进入活动页面。
    - 未登陆的用户访问用户中心重定向到登录页面。
    - 访问404页面重新定向到首页。


301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。（自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。）

> **HTTP状态码304是多好还是少好？**

服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

状态码304不应该认为是一种错误，而是对客户端**有缓存情况下**服务端的一种响应。

搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

**产生较多304状态码的原因：**

- 页面更新周期长或不更新
- 纯静态页面或强制生成静态html

**304状态码出现过多会造成以下问题：**

- 网站快照停止；
- 收录减少；
- 权重下降。



`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有语法错误，当错误发生时，需修改请求的内容后再次发送请求。
- 「**403 Forbidden**」表示**服务器禁止访问**资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在**服务器上不存在或未找到**，所以无法提供给客户端。



`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

#### HTTP常见字段

**Host字段**

客户端发送请求时，用来指定服务器的域名。`Host: www.A.com`

有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。



**Content-Length字段**

服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。`Content-Length: 1000`

大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，**HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**。



**Connection 字段**

`Connection` 字段最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221021114905858.png" alt="image-20221021114905858" style="zoom:30%;" />

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。（一般是TCP三次握手建立客户端与服务端连接，四次挥手断开连接）

TTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

```text
Connection: Keep-Alive
```

开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。



**Content-Type 字段**

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

```text
Content-Type: text/html; charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。

```text
Accept: */*
```

上面代码中，客户端声明自己可以接受任何格式的数据。



**Content-Encoding 字段**

`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

```text
Content-Encoding: gzip
```

上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

```text
Accept-Encoding: gzip, deflate
```

#### HTTP常见请求头

**1.Accept**

+ Accept:text/html 浏览器可以接受服务器返回的类型为 text/html
+ Accept: */* 代表浏览器可以处理所有类型（一般浏览器给服务器都是发这个）

**2.Accept-Encoding**

+ Accept-Encoding：gzip，deflate 浏览器声明自己接受的编码方式，通常指定压缩方法，是否支持压缩，支持什么压缩方法

**3.Accept-Language**

浏览器声明自己接受的语言

**4.Connection**

+ Connection：keep-alive 当一个网页打开完成后，客户端和服务端之间用于传输HTTP报文的TCP连接不会中断，如果客户端再次访问这个服务器的网页，客户端和服务端会继续使用这条已经建立的连接（HTTP/1.1 默认开启）
+ Connection：close 一个request完成后，TCP连接关闭，下次传输需要重新建立TCP连接（三次握手）

**5.Host（发送请求时，该报头域是必须的）**

+ Host：www.baidu.com 请求报头域用于指定请求资源的Internet主机号和端口号，通常从HTTP的URL中提取出来

**6.Referer**

+ **Referer:https://www.baidu.com/?tn=62095104_8_oem_dg** 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

**7.User-Agent**

+ User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

**8.Cache-Control**

+ **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
+ **Cache-Control:public**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
+ **Cache-Control:must-revalidate** 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
+ **Cache-Control:no-cache** 响应不会被缓存,而是实时向服务器端请求资源。
+ **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
+ **Cache-Control:no-store **在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

**9.Cookie**

用来存储一些用户信息，让服务器辨别用户身份，比如Cookie会存储一些用户的用户名和密码，用户登录后客户端会产生一个Cookie存储，浏览器再通过读取Cookie信息去服务器验证。

**9.Range（用于断点续传）**

+ **Range:bytes=0-5** 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

### 常见请求方法

#### localStorage、sessionStorage、cookie几种web存储方式区分

#### GET 和 POST有什么区别

**GET: 向服务器获取数据；**

**POST：将实体提交到指定的资源，通常会造成服务器资源的修改；**

+ **应用场景：**GET请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
+ **是否缓存：** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
+ **发送的报文格式：** Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
+ **安全性：** Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
+ **请求长度：** 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
+ **参数类型：** post 的参数传递支持更多的数据类型。

#### GET 和 POST 方法都是安全和幂等的吗？

+ 在 HTTP 协议里，所谓的**「安全」**是指请求方法不会「破坏」服务器上的资源。
+ 所谓的**「幂等」**，意思是多次执行相同的操作，结果都是「相同」的。

如果从 RFC 规范定义的语义来看：

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

#### put请求



### HTTP缓存技术

对于重复性的HTTP请求，可以把这对[请求-响应]的数据**缓存到本地**，下次可以直接读取本地数据，不用再向服务器发出请求。

HTTP缓存技术可以提高HTTP/1.1的性能。

HTTP缓存分为：**强制缓存和协商缓存**

#### 强制缓存

强制缓存是指只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221024201930637.png" alt="image-20221024201930637" style="zoom:28%;" />

强制缓存利用下面HTTP响应头部实现，都表示资源在客户端缓存的有效期：

+ `Cache-Control`，是一个相对时间
+ `Expires`，是一个绝对时间

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

+ 浏览器第一次访问服务器，服务器会在返回资源同时，在Response头部加上Cache-Control，Cache-Control设置了过期时间的大小
+ 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
+ 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

#### 协商缓存

在浏览器使用开发者工具的时候，`304状态码`告诉浏览器可以使用本地缓存的资源，这种通过服务器告诉客户端是否可以使用缓存的方式被称为协商缓存。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221024204825315.png" alt="image-20221024204825315" style="zoom:37%;" />

上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现。

**第一种：**请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：

- 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
- 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

**第二种：**请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：

- 响应头部中 `Etag`：唯一标识响应资源；
- 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，**这时 Etag 的优先级更高**，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。

**为什么 ETag 的优先级更高？**

这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：

1. 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
3. 有些服务器不能精确获取文件的最后修改时间。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

下图是强制缓存和协商缓存的工作流程：

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221024211955094.png" alt="image-20221024211955094" style="zoom:29%;" />

总结使用Etag字段实现协商缓存的过程：

+ 当浏览器第一次请求访问服务器资源，服务器在返回这个资源的同时，会在Response头部加上Etag唯一标识，这个唯一标识的值是根据当前请求的资源生成的。
+ 当浏览器再次请求访问服务器中该资源时，首先会检查强制缓存是否过期（浏览器决定，对比请求时间和Response头部中的Cache-Control）
  + 如果没有过期，直接使用本地缓存
  + 如果缓存过期，会在Request头部加上If-None-Match字段，该字段的值就是ETag唯一标识
+ 服务器再次受到请求后，会根据**请求中的If-None—Match值与当前请求的资源生成的唯一标识（ETag）进行比较**：
  + 如果值相等，返回304 Not Modeified，不会返回资源
  + 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
+ 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

### HTTP特性

到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

#### HTTP/1.1 优点

HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。

1. 简单

HTTP基本的报文格式是`header + body`，头部信息也是`keey-value`简单文本的形式，易于理解。

2. 灵活和易于扩展

HTTP里的各种请求方法、URL、状态码、头部字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。

同时，由于HTTP工作在应用层，它的下层可以随意变化：

+ HTTPS就是在HTTP和TCP之间增加了SSL/TLS安全传输层
+ HTTP/1.0 和 HTTP/2.0传输协议使用的是TCP协议，而HTTP/3.0改用UDP协议

3. 应用广泛和跨平台

#### HTTP/1.1 缺点

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

1. **无状态**双刃剑

无状态的**好处**，因为服务器不会去记忆HTTP的状态，不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。

`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

> 客户端第一次发请求后，服务器会生成Cookie，用来保存客户的信息，并在响应报文中添加Cookie后返回。
>
> 第二次以后，客户端发送请求时，在请求报文中添加Cookie，服务器就能识别到Cookie中保存的用户身份。

2. **明文传输**双刃剑

明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取。

3. **不安全**

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

#### HTTP/1.1的性能

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。

1. **长连接**

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221027125127196.png" alt="image-20221027125127196" style="zoom:30%;" />

当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。

2. **管道网络传输**

同一个TCP连接中，客户端能发送多个请求，第一个请求发出去后，不需要等待第一个请求的结果就可以直接发送第二个请求，可以**减少整体的响应时间**

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221027125427134.png" alt="image-20221027125427134" style="zoom:30%;" />

但是，**服务器必须按照发送请求的顺序返回响应**，如果处理第一个请求花费的时间过长，那么后面的请求都会被阻塞，这被称为【队头阻塞】

所以，HTTP/1.1的管道网络传输只解决了请求的队头阻塞，没有解决响应的队头阻塞。

> **注意：**
>
> 实际上，HTTP/1.1的管道通信默认不开启，而且很多浏览器不支持，所以下面的讨论都建立在不是管道通信的基础上。

总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

### HTTP与HTTPS

#### HTTP与HTTPS有哪些区别

+ HTTP是超文本传输协议，明文传输不安全。HTTPS解决了HTTP不安全的问题，在TCP和HTTP网络层加入了SSL/TLS安全协议，使得报文可以加密传输。
+ HTTP建立连接相对简单，在TCP三次握手后可以进行HTTP传输，而HTTPS在TCP三次握手的基础上还需要SSL/TLS握手，才可以加密传输。
+ 默认端口不一样，HTTP是80，HTTPS是443
+ HTTPS协议需要向CA（证书权威认证）申请数字证书，来保证服务器的身份是可信的。

#### HTTPS解决了HTTP哪些问题

HTTP由于是明文传输，在安全上可能会存在：**被窃听（账号密码），被篡改（添加小广告），被冒充（假淘宝）**。

HTTPS在HTTP层和TCP层中间加入了`SSL/TLS`协议，可以很好地解决上述风险：

+ 信息加密：加密传输无法窃取
+ 校验机制：不能篡改信息
+ 身份证书：证明是官方网站

HTTPS如何解决？

+ **混合加密**保证了信息机密性
+ **摘要算法**实现**完整性**，为数据生成独一无二的**指纹**，指纹用来检验数据的完整性，防止篡改
+ 服务器公钥放入**数字证书**中，解决了窃听的风险

1. **混合加密**

HTTPS采用**对称加密**和**非对称加密**的**混合加密**方式：

> 对称加密：用一个公钥进行加密和解密，问题在于服务器把公钥发送给客户端的过程中存在风险。
>
> 因此，先使永非对称加密（有一对公钥和私钥），服务器存放私钥，将公钥发送给客户端，客户端对数据用公钥加密，但是解密只能使用私钥解密，这样不存在信息泄露风险。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221102142041244.png" alt="image-20221102142041244" style="zoom: 33%;" />

+ HTTPS先采用非对称加密，安全交换`会话秘钥`，这个后续不再使用非对称加密
+ 通信过程中采用对称加密，刚刚安全交换的会话秘钥就是公钥

这样即可以保证传输速度，又可以保证传输安全，因为：

+ 对称加密只有一个秘钥，运算速度快，但是秘钥必须保密不安全
+ 非对称加密安全，有公钥和私钥，公钥任意发放私钥自己保存，但是运算速度满

2. **摘要算法 + 数字签名**

为了保证数据的完整性，也就是传输过程中数据不会被篡改，使用摘要算法。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221102143856092.png" alt="image-20221102143856092" style="zoom:33%;" />

发送方用摘要算法（也就是哈希函数）根据传输数据计算出哈希值A（被称为指纹），这个指纹是唯一的，哈希函数不可逆，也就无法通过哈希值倒推出数据；接收方在收到数据后对数据再做一次哈希运算，比较计算得出的哈希值B和哈希值A，结果相同就证明传来的数据完整的。

**注意：**上述情况，如果传输过程中将数据和哈希值全部替换的话，接收方也会收到假数据，所以在此基础上又使用了非对称加密。

> 补充非对称加密：私钥自己管理，公钥随意发放，而且公钥和私钥可以双向解密（就是用公钥加密，私钥可以解密；私钥加密，公钥也可以解密）
>
> 但是这两种方式的用途不同：
>
> + 公钥加密 + 私钥解密：公钥是可以随意发放的，但是只能用私钥解密，也就是保证了**数据传输的安全**，只有真正的接收方（有私钥的服务器）才可以正确接收到数据。
> + 私钥加密 + 公钥解密：私钥不可泄露，私钥加密后，别人无法用其他数据替换这个数据，因为别人没有私钥，如果接收方能用公钥正确解析出数据，说明**传输过程中数据没有被替换**，因为被替换的数据无法用公钥解密。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221102144900091.png" alt="image-20221102144900091" style="zoom:33%;" />

所以，先对数据哈希运算，计算得出哈希值A后用私钥加密，得到**数字签名**，把数据和数字签名一同发送给接收方，接受方先对数据进行哈希运算得到哈希值B，再对数字签名用公钥解密：1）首先数字签名能用公钥解密确保了整个数据和哈希值A没有被替换。2）哈希值B和公钥解密后的数字签名相同又确保了数据的没有被篡改

3. **数字证书**

前面通过哈希算法确保了数据的完整性，又通过哈希算法和数字签名确保了数据的完整性和不被篡改。但是实际中，**公钥有可能是伪造**的，没有身份验证，服务器伪造，发送公钥，依然功亏一篑。

所以，网站在使用HTTPS之前，需要向 **CA** 申请颁发**数字证书**，数字证书有**证书持有者信息和证书持有者的公钥**。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221103105827856.png" alt="image-20221103105827856" style="zoom:35%;" />

CA 负责颁发证书以及验证证书的合法性。客户端拿到服务器的证书后，需要验证证书编号是否能在对应的CA机构查到，还要验证证书中的域名和当前访问的域名是否一致，并可以拿到服务器的公钥进行对称加密。

为了防止证书伪造，需要加工数字证书成为**数字签名**。

下图中左侧是数字签名的制作过程，右侧是验证过程

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221103110631037.png" alt="image-20221103110631037" style="zoom:33%;" />

> 下面是HTTPS的详细过程

#### HTTPS如何建立连接，期间交互了什么？

SSL/TLS 协议基本流程：

+ 客户端向服务端索要服务器的公钥
+ 双方通过服务器的公钥和私钥协商获得会话秘钥，这一步也叫做非对称加密
+ 后续通过会话秘钥进行加密通信，这一步叫做对称加密

前两步是 SSL/TLS 的建立过程，也就是TLS握手阶段。

TLS 的握手阶段涉及四次通信，涉及不同的秘钥交换算法，TLS的具体流程也会有不同，现在的秘钥交换算法有`RSA`和`ECDHE`。

详见RSA握手解析。

#### HTTPS的应用数据如何保证完整性？

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png)

具体过程如下：

- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

#### HTTPS一定安全可靠么

这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img" style="zoom: 50%;" />

具体过程如下所示：

+ 客户端向服务器发起HTTPS建立连接请求，被假基站转发到了中间人服务器，接着中间人向服务器发起HTTPS建立连接请求，此时客户端和中间人进行TLS握手，中间人和服务器进行TLS握手。
+ 客户端与中间人进行TLS握手，中间人发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，期间生成三个随机数，并且上述过程都采用非对称加密传递数据，根据随机数生成会话秘钥，后续基于会话秘钥进行对称加密传输数据。
+ 同理，服务端也完成了和中间人的TLS四次握手
+ 在后续的通信过程中，中间人能拿着客户端的数据，从服务端获取相应数据

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA.png)

如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。

所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。

另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

> 为什么抓包工具能截取 HTTPS 数据？

很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。

对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:

1. 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
2. 中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；

中间人要拿到私钥只能通过如下方式：

1. 去网站服务端拿到私钥；
2. 去CA处拿域名签发私钥；
3. 自己签发证书，切要被浏览器信任；

不用解释，抓包工具只能使用第三种方式取得中间人的身份。

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。

抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

> 如何避免被中间人抓取数据？

我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。

当然，我们还可以通过 **HTTPS 双向认证**来避免这种问题。

一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png)

如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

### HTTP/1.1 HTTP/2 HTTP/3 演化

#### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

**性能上：**

+ 使用长连接的方式改善了HTTP/1.0 短连接造成的性能开销
  + 短连接，每发一次请求都要进行TCP三次握手
+ 支持管道网络传输，只要第一个请求发送出去，不必等其回来，就可以发送第二个请求，可以减少整体的等待时间

**HTTP/1.1 性能瓶颈：**

+ 请求/响应头部 未经压缩就发送，首部信息越多，延迟越大。只能压缩Body部分
+ 每次发送相同的首部浪费资源
+ 服务器按照请求的顺序响应，如果服务器响应慢，客户端一直受不到请求，也就是队头阻塞
+ 没有请求优先控制
+ 请求只能从客户端开始，服务器只能被动响应



