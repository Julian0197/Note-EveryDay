## HTTP常见面试题

### HTTP基本概念

#### HTTP是什么

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

> 那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议 ，这种说法正确吗？

这种说法是**不正确**的。因为也可以是「服务器< -- >服务器」，所以采用**两点之间**的描述会更准确。

#### HTTP常见状态码

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221020160851997.png" alt="image-20221020160851997" style="zoom:33%;" />

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。



`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」200 OK表示客户端发来的请求被服务器端正常处理了。

- 「**204 No Content**」该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

  

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
  - **使用场景：**
    - 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
    - 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

- 「**302 Found**」表示**临时重定向**，该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
  - 使用场景：
    - 当我们在做活动时，登录到首页自动重定向，进入活动页面。
    - 未登陆的用户访问用户中心重定向到登录页面。
    - 访问404页面重新定向到首页。


301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。（自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。）

> **HTTP状态码304是多好还是少好？**

服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

状态码304不应该认为是一种错误，而是对客户端**有缓存情况下**服务端的一种响应。

搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

**产生较多304状态码的原因：**

- 页面更新周期长或不更新
- 纯静态页面或强制生成静态html

**304状态码出现过多会造成以下问题：**

- 网站快照停止；
- 收录减少；
- 权重下降。



`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有语法错误，当错误发生时，需修改请求的内容后再次发送请求。
- 「**403 Forbidden**」表示**服务器禁止访问**资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在**服务器上不存在或未找到**，所以无法提供给客户端。



`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

#### HTTP常见字段

**Host字段**

客户端发送请求时，用来指定服务器的域名。`Host: www.A.com`

有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。



**Content-Length字段**

服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。`Content-Length: 1000`

大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，**HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**。



**Connection 字段**

`Connection` 字段最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221021114905858.png" alt="image-20221021114905858" style="zoom:30%;" />

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。（一般是TCP三次握手建立客户端与服务端连接，四次挥手断开连接）

TTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

```text
Connection: Keep-Alive
```

开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。



**Content-Type 字段**

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

```text
Content-Type: text/html; charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。

```text
Accept: */*
```

上面代码中，客户端声明自己可以接受任何格式的数据。



**Content-Encoding 字段**

`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

```text
Content-Encoding: gzip
```

上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

```text
Accept-Encoding: gzip, deflate
```

### GET 与 POST

#### GET 和 POST有什么区别

**GET: 向服务器获取数据；**

**POST：将实体提交到指定的资源，通常会造成服务器资源的修改；**

+ **应用场景：**GET请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
+ **是否缓存：** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
+ **发送的报文格式：** Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
+ **安全性：** Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
+ **请求长度：** 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
+ **参数类型：** post 的参数传递支持更多的数据类型。

#### GET 和 POST 方法都是安全和幂等的吗？

+ 在 HTTP 协议里，所谓的**「安全」**是指请求方法不会「破坏」服务器上的资源。
+ 所谓的**「幂等」**，意思是多次执行相同的操作，结果都是「相同」的。

如果从 RFC 规范定义的语义来看：

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

### HTTP缓存技术

对于重复性的HTTP请求，可以把这对[请求-响应]的数据**缓存到本地**，下次可以直接读取本地数据，不用再向服务器发出请求。

HTTP缓存技术可以提高HTTP/1.1的性能。

HTTP缓存分为：**强制缓存和协商缓存**

#### 强制缓存

强制缓存是指只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221024201930637.png" alt="image-20221024201930637" style="zoom:28%;" />

强制缓存利用下面HTTP响应头部实现，都表示资源在客户端缓存的有效期：

+ `Cache-Control`，是一个相对时间
+ `Expires`，是一个绝对时间

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

+ 浏览器第一次访问服务器，服务器会在返回资源同时，在Response头部加上Cache-Control，Cache-Control设置了过期时间的大小
+ 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
+ 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

#### 协商缓存

在浏览器使用开发者工具的时候，`304状态码`告诉浏览器可以使用本地缓存的资源，这种通过服务器告诉客户端是否可以使用缓存的方式被称为协商缓存。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221024204825315.png" alt="image-20221024204825315" style="zoom:37%;" />

上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现。

**第一种：**请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：

- 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
- 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

**第二种：**请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：

- 响应头部中 `Etag`：唯一标识响应资源；
- 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，**这时 Etag 的优先级更高**，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。

**为什么 ETag 的优先级更高？**

这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：

1. 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
3. 有些服务器不能精确获取文件的最后修改时间。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

下图是强制缓存和协商缓存的工作流程：

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221024211955094.png" alt="image-20221024211955094" style="zoom:29%;" />

总结使用Etag字段实现协商缓存的过程：

+ 当浏览器第一次请求访问服务器资源，服务器在返回这个资源的同时，会在Response头部加上Etag唯一标识，这个唯一标识的值是根据当前请求的资源生成的。
+ 当浏览器再次请求访问服务器中该资源时，首先会检查强制缓存是否过期（浏览器决定，对比请求时间和Response头部中的Cache-Control）
  + 如果没有过期，直接使用本地缓存
  + 如果缓存过期，会在Request头部加上If-None-Match字段，该字段的值就是ETag唯一标识
+ 服务器再次受到请求后，会根据**请求中的If-None—Match值与当前请求的资源生成的唯一标识（ETag）进行比较**：
  + 如果值相等，返回304 Not Modeified，不会返回资源
  + 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
+ 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

### HTTP特性

到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

#### HTTP/1.1 优点

HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。

1. 简单

HTTP基本的报文格式是`header + body`，头部信息也是`keey-value`简单文本的形式，易于理解。

2. 灵活和易于扩展

HTTP里的各种请求方法、URL、状态码、头部字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。

同时，由于HTTP工作在应用层，它的下层可以随意变化：

+ HTTPS就是在HTTP和TCP之间增加了SSL/TLS安全传输层
+ HTTP/1.0 和 HTTP/2.0传输协议使用的是TCP协议，而HTTP/3.0改用UDP协议

3. 应用广泛和跨平台

#### HTTP/1.1 缺点

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

1. **无状态**双刃剑

无状态的**好处**，因为服务器不会去记忆HTTP的状态，不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。

`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

> 客户端第一次发请求后，服务器会生成Cookie，用来保存客户的信息，并在响应报文中添加Cookie后返回。
>
> 第二次以后，客户端发送请求时，在请求报文中添加Cookie，服务器就能识别到Cookie中保存的用户身份。

2. **明文传输**双刃剑

明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取。

3. **不安全**

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

#### HTTP/1.1的性能

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。

1. **长连接**

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221027125127196.png" alt="image-20221027125127196" style="zoom:30%;" />

当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。

2. **管道网络传输**

同一个TCP连接中，客户端能发送多个请求，第一个请求发出去后，不需要等待第一个请求的结果就可以直接发送第二个请求，可以**减少整体的响应时间**

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221027125427134.png" alt="image-20221027125427134" style="zoom:30%;" />

但是，**服务器必须按照发送请求的顺序返回响应**，如果处理第一个请求花费的时间过长，那么后面的请求都会被阻塞，这被称为【队头阻塞】

所以，HTTP/1.1的管道网络传输只解决了请求的队头阻塞，没有解决响应的队头阻塞。

> **注意：**
>
> 实际上，HTTP/1.1的管道通信默认不开启，而且很多浏览器不支持，所以下面的讨论都建立在不是管道通信的基础上。

总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

### HTTP与HTTPS

+ HTTP是超文本传输协议，明文传输不安全。HTTPS解决了HTTP不安全的问题，在TCP和HTTP网络层加入了SSL/TLS安全协议，使得报文可以加密传输。
+ HTTP建立连接相对简单，再TCP三次握手后可以进行HTTP传输，而HTTPS在TCP三次握手的基础上还需要SSL/TLS握手，才可以加密传输。
+ 默认端口不一样，HTTP是80，HTTPS是443
+ HTTPS协议需要向CA（证书权威认证）申请数字证书，来保证服务器的身份是可信的。

#### HTTP与HTTPS有哪些区别

